# Buffer Overflow 0

In this challenge we are given two files, an executable vuln and the code for this in vuln.c. Open the vuln.c file in the editor of your choice.

First thing we should note is that again flag is setup, but this time it's not defined, only the variable is setup. Next on line 10 we have something very intresting, a defined sigsegv_handler - these are used to handle a segmentation fault, and in our case here it is going to print the flag!
![image](https://user-images.githubusercontent.com/6153549/161445710-a8063541-f9a0-4dba-9e08-252694524160.png)

Another thing to note in the main function a file is opened, flag.txt and set to flag. If you want to test locally first you will need to make a flag.txt file and make the vuln file executable with 'chmod +x vuln'
![image](https://user-images.githubusercontent.com/6153549/161445729-0918dff5-6d3b-44de-83cb-40306f101b2d.png)

The rest of the application is pretty striaghtforward, we have a print statement asking for input, then a gets (which is a C function to get input from stdin), followed by calling the vuln function. What should be noted is that in our input we can send in up to 100 bytes, however in the vuln function the string is copied into a varible of only 16 bytes.

![image](https://user-images.githubusercontent.com/6153549/161445747-038184eb-a897-495b-9239-4bd81d40dbfc.png)

![image](https://user-images.githubusercontent.com/6153549/161445769-52c8058a-dfe2-4304-a725-36469934f14a.png)

So again we have what we need, an input that holds up to 100 bytes is getting copied into a variable of 16 bytes, and if we generate a segfault we should get the flag, so all we need to do is send a payload big enough!
![image](https://user-images.githubusercontent.com/6153549/161445898-2fbbd2ce-b904-4012-8534-fd469a4c33af.png)
