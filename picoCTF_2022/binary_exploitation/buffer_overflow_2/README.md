# Buffer Overflow 2

Alright another buffer overflow!! lets start by taking a peek at the vuln.c file.

First we see there is a win() function again that prints the flag, however this time, if we look, the function takes two arguments.

![image](https://user-images.githubusercontent.com/6153549/162541265-7cdcf83c-168e-4bea-beca-3c736d0c192b.png)

These arguements are then checked to see if they match specific values, if they do then we print the flag!

![image](https://user-images.githubusercontent.com/6153549/162541383-b3847e7a-8a3c-49f6-9ce4-8b7e45fd7613.png)

The rest of the application is the same. So to start with I'm not going to create the flag.txt just yet, the reason is the error message prints prior to checking the variables. So in this way, I can make sure that the overflow jumped to the right spot and then can take a look at the stack. So lets do the usual! make your pattern, run it, and find the offset.

![image](https://user-images.githubusercontent.com/6153549/162541603-3c44a408-9422-4e66-ab1c-4f2190686476.png)

![image](https://user-images.githubusercontent.com/6153549/162541644-160e47ce-602a-47fe-9c0a-c9b9d955ef0e.png)

Alright so we got EIP control after 112 bytes. Next lets find the address for the win() function.

![image](https://user-images.githubusercontent.com/6153549/162541693-ca638a96-3cd0-44bd-bf5d-0457ac31b683.png)

Ok, so lets make our template for pwntools and put in the data we know.

`pwn template --host saturn.picoctf.net --port 1234 ./vuln > solution.py`

![image](https://user-images.githubusercontent.com/6153549/162541815-41d14795-31d2-4772-a556-c1269243cb34.png)

you can do the usual run to make sure it's working at this point; it should tell you to create the flag file; this means we jumped correctly.

So when a program calls a function and needs to pass it variables it will put those variables on the stack, push a return address, then call the function. Lets take a look at this in GDB. First create flag.txt so we don't get hung up there and then we'll set a breakpoint at the start of the win() function we jump to, and finally pass in some varaibles at the end of our string. You set a break point in gdb using `break *0x08049296`

`r <<< $(python -c "print(b'A'*112+b'\x96\x92\x04\x08'+b'C'*20)")`
Some quick notes on this command:
* The <<< is used to pipe the python command into the run of the appliction
* The memory address we are jumping to has to be put in reverse, this is due to how items are pushed and read from memory

![image](https://user-images.githubusercontent.com/6153549/162542323-578186f0-3db6-4acb-bd8e-0c8a48ee8fb8.png)

Running this we should hit the breakpoint.

![image](https://user-images.githubusercontent.com/6153549/162542351-ff79c0d0-1b2d-4e1a-9ec1-ea33ec61bbc0.png)

if we use next to go command by command (n for short) we see that we first open the flag.txt then we have a compare to make sure it's not empty (if it was empty this compare would fail and you'd get kicked back). Aslong as the flag.txt is there we will move on and can watch for the next compare (CMP). Without going into to much detail about assembly language, the if statements in the vuln.c translate into the compare within the assembly language; this is in the "code" section of gdb-peda. Hitting 'n' you can watch as the stack, variables, and code change.

![image](https://user-images.githubusercontent.com/6153549/162542501-5fa121f8-6952-40e0-94cf-6c8ffa916da4.png)

Our two compares are here.

![image](https://user-images.githubusercontent.com/6153549/162542519-9ed268cd-c865-49e4-bb96-cd81af717ef8.png)

So we can see that we're looking at our C's; we know this because ebp+0x8 (ebp plus 8 bytes) lands us at our C's. So with this we can guess where to put our variables, if you wanted to get crazy or if the jump was a bit further or more complex you could use a pattern, but we don't need to here. 

![image](https://user-images.githubusercontent.com/6153549/162542640-0ebf6596-aedc-4e44-a686-9c2d463a4757.png)

So we need to send 112 "A"s followed by our win function, followed by 4bytes of nothing, then our two arguments with '0xCAFEF00D' being first (remember that we put this onto the stack in reverse order). Again, you have four bytes of nothing because we're 8 bytes from EBP, the first four are A's the next four are the start of our C's (normally this would have been the return address pushed to the stack). The second argument is at ebp+0xc or 12 bytes from EBP which means it will follow the first argument. Lets test it.

`r <<< $(python -c "print(b'A'*112+b'\x96\x92\x04\x08'+b'CCCC'+b'\x0D\xF0\xFE\xCA'+b'\x0D\xF0\x0D\xF0')")`

![image](https://user-images.githubusercontent.com/6153549/162542853-5c8528e3-a704-4d6b-99fa-b49e4dac2c47.png)

![image](https://user-images.githubusercontent.com/6153549/162542877-4479d407-f6a7-4e23-8098-504d41c80db9.png)

As we can see we were able to match the data and get the flag, if you just continue you'll see a segfault with EIP set to CCCC which we'd expect.

![image](https://user-images.githubusercontent.com/6153549/162542907-449ecccd-39bc-4ce8-a5d1-f2852c3437c7.png)

![image](https://user-images.githubusercontent.com/6153549/162542937-3ca69b8a-e52c-495a-88f4-36bd08cb7d4b.png)

Let's modify our script and run it now against picoCTF.

![image](https://user-images.githubusercontent.com/6153549/162543812-6ecf2e8a-4171-43df-9576-f9aec2494f0d.png)

![image](https://user-images.githubusercontent.com/6153549/162543065-420bc3f5-58de-4f05-9b8e-23d2e2397bbc.png)
