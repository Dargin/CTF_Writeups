# Buffer Overflow 2

Alright another buffer overflow!! lets start by taking a pick at the vuln.c file.

First we see there is a win() function again that prints the flag, however this time, if we look, the function takes two arguments.

These arguements are then checked to see if they match specific values, if they do then we print the flag!

The rest of the application is the same. So start with I'm not going to create the flag.txt just yet, the reason is the error message prints prior to checking the variables. So in this way, I can make sure that the overflow jumped to the right spot and then can take a look at the stack. So lets do the usual! make your pattern, run it, and find the offset.

Alright so we got EIP control after 112 bytes. Next lets find the adress for the win() function.

Ok, so let smake our template for pwntools and put in the data we know.

So when a program calls a function and needs to pass it variables it will put those variables on the stack, push a return address, then call the function. Lets take a look at this in GDB. First create flag.txt so we don't get hung up there and then we'll set a breakpoint at the start of the win() function we jump to, and finally pass in some varaibles at the end of our string.

if we use next to go command by command (n for short) we see that we first open the flag.txt then we have a compare to make sure it's not empty (if it was empty this compare would fail and you'd get kicked back). Aslong as the flag.txt is there we will move on and can watch for the next compare (CMP).

So we can see that we're looking at our C's; we know this because ebp+0x8 land us at our C's. So with this we can guess where to put our variables, if you wanted to get crazy or if the jump was a bit further or more complex you could use a pattern, but we don't need to here. So we need to send 112 "A"s followed by our win function, followed by 4bytes of nothing, then our two arguments with '0xCAFEF00D' being first. Again, you have four bytes of nothing because we're 8 bytes from EBP, the first four are A's the next four are the start of our C's. The second argument is at ebp+0xc or 12 bytes from EBP. If this was running as normal the first four C's would be our return address pushed to the stack. Lets test it.
r <<< $(python -c "print(b'A'*112+b'\x96\x92\x04\x08'+b'CCCC'+b'\x0D\xF0\xFE\xCA'+b'\x0D\xF0\x0D\xF0')")

As we can see we were able to match the data and get the flag, if you just continue you'll see a segfault with EIP set to CCCC which we'd expect.

Let's modify our script and run it now against picoCTF.