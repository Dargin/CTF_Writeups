# X-Sixty-What

Looks like we got another buffer overflow, but the note on this one says it's x64. When it comes to programs the two most common is 32-bit (x86), which is what we've been dealing with, and 64-bit (x64). x64 base programs use a different set of registers and memory spacing uses 8 bytes instead of 4, but for these challenges most things will be the same. Lets start by using our checksec and seeing what might be turned on.

![image](https://user-images.githubusercontent.com/6153549/162349905-a48bd1a8-b2e6-4a20-9d77-b54e4be746b6.png)

So no canary, partial RELRO, and no PIE (Position Indepent Executable). So with this we see NX is disabled which means the stack isn't executable, that's not going to be a problem for us as we'll see - we're not putting shellcode into the stack. No PIE is important as that means we can guess at the memory space. As the warning shows it might be different from our box to the box on picoCTF but it should be close.

Ok so now lets take a look at the vuln.c and see what we're dealing with. First thing we notice is just like Buffer Overflow 1 there is a function we'll want to call, this time it's not win() though it's flag().

![image](https://user-images.githubusercontent.com/6153549/162350229-662d9bc0-ab25-48a7-86a9-0bda99b97e44.png)

Next we see a vuln() function that is taking our input, into a variable with a set limit, but our input is not limited - again a simple buffer overflow. Main() is doing it's usual thing, setting up the gid to open the flag and then calling the vuln function. So just like buffer overflow 1 we need to simply overflow the program and overwrite RBP to point to the flag function.

![image](https://user-images.githubusercontent.com/6153549/162350607-2f14a5ef-a7dd-4799-9d60-7039aa58ccbc.png)

So we can follow the same process as buffer overflow 1; lets open the program in gdb-peda, generate our pattern, input it and find the offset!

![image](https://user-images.githubusercontent.com/6153549/162351034-4d990ec5-17c7-4110-9dd1-c7ade7b53987.png)

![image](https://user-images.githubusercontent.com/6153549/162351985-0710f028-d36d-42ca-8e89-cc0e018b68d1.png)

![image](https://user-images.githubusercontent.com/6153549/162352363-3817254d-695c-4dfd-8897-ed930ceaca19.png)

So the overwrite comes out to 64 bytes; however remember that with 64 bit programs memory is in 8bytes so we need to add 8 giving us our buffer of 72. Now, same as buffer overflow 1 we need to find the address of the function we want to jump to (flag()); however in this case we don't want to jump to the start of flag() we want to jump to the second instruction. Hint 2 on picoCTF will give you similar guidance; this is to avoid some weird segmentation faults that can sometimes happen if you jump straight to the function. Let's find the address we want to go to by disassembling the flag function and getting the address for the second command.

![image](https://user-images.githubusercontent.com/6153549/162353227-4401c8cb-2719-45fc-a86f-471a69f12b7a.png)

So we want to jump to 0x40123a - lets get our exploit script setup using pwntools -- 'pwn template --host saturn.picoctf.net --port 1234 ./vuln >> solution.py'
Lets start by setting up our flag memory address, as this is a 64 bit application we'll use p64() instead of p32().

![image](https://user-images.githubusercontent.com/6153549/162354468-faf7624f-9f19-40d4-af89-74410d10927c.png)

Now lets setup our payload, again we know that it's 72 bytes to overwrite RBP.

![image](https://user-images.githubusercontent.com/6153549/162355437-93660799-98b9-4896-8af5-f2b346c7357a.png)

Finally just for fun, lets receive the line that gets printed and then send our payload.

![image](https://user-images.githubusercontent.com/6153549/162354802-0af275ca-d77f-4b34-b505-0384eb44bf6a.png)

![image](https://user-images.githubusercontent.com/6153549/162355527-f8e76ec8-f770-4f5a-a91d-07836466231d.png)

As we can see, this printed my test flag. Lets run it against the server!

![image](https://user-images.githubusercontent.com/6153549/162355634-52146f51-2216-4a5a-b6cf-73c10adc5070.png)

We didn't get the flag, but if we remember the challenge it stated that sometimes memory can be off, so lets change our flag by one address up. You could script this, but we'll just increase by one a few times and see where we land.

![image](https://user-images.githubusercontent.com/6153549/162355740-29d27eea-0cf9-4a7f-a5b9-b48ee77fe596.png)

![image](https://user-images.githubusercontent.com/6153549/162355870-d9d75d07-48d4-4935-aec9-b2dddee9bee6.png)

We actually got kinda lucky and a single byte change gave us the flag!
