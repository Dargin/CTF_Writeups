# Flag Leak

Lets take a look and see what we got, first grab the two files and lets look at the vuln.c per usual.

First thing we see is a readflag() function that is opening the flag.txt file into the buf variable which is sent to it as part of the function call.

So this is intresting as it means we'll have the flag on the stack, and based on the challenge name we're gonna want to leak it. So with that in min the next things we should notice is that scanf is used to pull in a string and then printf just prints it without specifing the output. This is vulnerable to something called format string attack. (https://owasp.org/www-community/attacks/Format_string_attack)

So let's give it a shot, if you read the OWASP page you'll see that with printf we can specify the format, we're going to use that with the '%n' which as stated in Table 2 on the OWASP page writes the number (n) of characters to a pointer and then we're going to add '$s' to tell it to treat it as a string so we can read the data. Let's test it real quick.

So we see a few different things coming up based on the number we put in. So lets write a quick loop to see if we can find flag.

'''python
from pwn import *

for i in range(100):
  try:
    io = process('./vuln')
    io.recvuntil(b">> ")
    print(i)
    io.sendline('%{}$s'.format(i).encode())
    io.recvline()
    leaked = io.recvline()
    if b"{" in leaked:
      print("Flag:", leaked)
      break
    else:
      print(leaked)
    io.close()
  except EOFError:
    pass
'''

So with this we see the flag is leaked at position 24; however the first part of the flag is cut off, this shouldn't matter because we know what that should be, let's try sending this to actual challenge. As you see it still cut off the first four characters, but we know what those are so no worries!
