# Buffer Overflow 1

We got another buffer overflow! Lets take a look at the vuln.c we're provided to see what the application is doing. First thing out the gate we see a win() function defined that's opening a flag.txt file and prints it out. Well that looks promising.

![image](https://user-images.githubusercontent.com/6153549/162099508-8826a1ed-3e33-4fe0-9ac3-44a78ab64b9f.png)

Next we see a vuln() function that is simply using gets to take our input and the variable we're inputing is set to the buffer size of 32. That's going to be our overflow point.

![image](https://user-images.githubusercontent.com/6153549/162099555-4709561f-4b2c-43dc-ad0b-02a30345a479.png)

The final function, which is of course main(), is simply setting the gid so it can open the file and then asks for the input before calling vuln().

![image](https://user-images.githubusercontent.com/6153549/162099609-3a741f1f-a319-410d-8b5f-76f0f92155eb.png)

A quick look at checksec shows us the security is turned off so this should be a striaghtforward overflow and jump to functionsthe win function.

![image](https://user-images.githubusercontent.com/6153549/162099696-e4c9ce76-91ee-43a4-ade3-bb7bd527c58c.png)

Lets get started by using gdb-peda to find our overflow; we could use pwntools to do this but I prefer to check it manually first.

![image](https://user-images.githubusercontent.com/6153549/162099797-e36945ae-66a8-4592-8eff-ddfb77f1394a.png)

Create our pattern with 'pattern create 200 pattern.txt' and send this to the input of the file.

![image](https://user-images.githubusercontent.com/6153549/162100003-3c29f720-39f4-4bab-9ebb-cdefa87055d2.png)

![image](https://user-images.githubusercontent.com/6153549/162100047-7e9c0b9e-5ed3-461a-9019-89d5be66038e.png)

We see that the segfault happens and EIP is overwritten with 0x41414641; without going into to much detail when doing basic buffer overflows you want to control the EIP (Extended Instruction Pointer - it tells the computer where to go next to execute the next command and controls the flow of a program.) So now we need to see how many bytes it took to overwrite the EIP we can do this with 'pattern_offset 0x41414641'.

![image](https://user-images.githubusercontent.com/6153549/162100086-10196cd1-475a-437d-8909-8aa84e8e87a0.png)

This tells us that we were overwriting EIP after 44 bytes. We can test this by sending 44 A's and then four B's (In hex A is equal to 0x41 and B is equal to 0x42). We see that EIP is now equal to 0x42424242 which is our string of B's showing we have the right location.

![image](https://user-images.githubusercontent.com/6153549/162100253-86ff5937-9354-447f-a2dc-253a0d89e528.png)

Now we need to find the address of the function we want to call, what we're looking to do is overflow the buffer and make EIP point to where we want to land. We can do this by typing 'info functions' in gdb-peda. We find that the win() function is at 0x0804932f

![image](https://user-images.githubusercontent.com/6153549/162100341-fcacfb47-5b0c-4ffd-8f27-4d99159615b9.png)

Alright, so we now have all the pieces we need to put this together. At this point lets switch to using pwntools so we can craft the exploit, verify it locally, then run it on the remote host. I like to start by making a template. This just helps set us up with a lot of things by default, for this challenge we don't really need it but I prefer to try and keep muscle memory for these things.

![image](https://user-images.githubusercontent.com/6153549/162100474-f52f4ab0-c42c-4922-9040-bff864fbba94.png)

In the template you'll want to go down to 'io = start()' so we can start putting together our payload. we already know the buffer size of 44 so lets set that with 'buffer = 44'. Next I set the variable elf to the static file, this is so I can just call the functions - again, a bit more then needed here especially because we already know the address we want to jump to, but it's good to understand what's going on. With the file defined we can now get the address using the symbols, if you print this variable you'll see it should match what we found with the info functions.

![image](https://user-images.githubusercontent.com/6153549/162100561-37d120af-2672-4a5a-b114-cf168b936194.png)

Now we define our payload, this is simply going to send 44 A's followed by the win_address; the nice thing about pwntools is that it puts the memory addresses in the right format, if you were doing this manually you would need to make sure you reversed. Other thing to note is that in python3 you cannot mix byte and string anymore, the 'b' infront of the string A is telling python we want the byte value - this is required as the memory address will be in byte format.

![image](https://user-images.githubusercontent.com/6153549/162100602-c3e8334f-cecb-4e80-ae40-7c26a0ae3219.png)

Now we add a line to send it to the executable. and everything else we can leave the same!

![image](https://user-images.githubusercontent.com/6153549/162100761-95b041b2-396d-4872-a34e-1904b0d9123a.png)

Lets give it a run locally and see if we get the flag - remember you need to have a flag.txt or you'll get an error; although that error would also let you know that you were in the right function.

![image](https://user-images.githubusercontent.com/6153549/162100859-71dc57c7-7a1a-4f52-a76d-887d1d2b9498.png)

Great! We see the flag printed right there at the end! Now just run it against the server and collect your flag!

![image](https://user-images.githubusercontent.com/6153549/162100958-1f8443cb-1c93-4c61-8af7-3da9c4a064e7.png)
